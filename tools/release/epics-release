#!/usr/bin/python
# This script release an EPICS package into the release area.
# It is written to work on an SVN repository. For each package released
# it will:
#   Create a branch named <package>-<version> if it does not exist
#   Import the RELEASE_SITE from the release area
#   Hardcode in configure/RELEASE any MODULE_VERSION variable
#   Check-in the changes
#   Build the module with INSTALL_LOCATION pointing to release area
#   	this will release the package in <package>/<version>-r<svnver>
#   Update the release area RELEASE_SITE
#
# Copyright 2008, Stanford University
# Author: Remi Machet <rmachet@slac.stanford.edu>
#
# Released under the GPLv2 licence <http://www.gnu.org/licenses/gpl-2.0.html>
#

import re
import sys
import shutil
import traceback
import tempfile
import commands
import stat
import os

def execute(cmd):
	global dictConfig

	iRetCode = os.system("/bin/bash -c '(" + cmd + ")' > " + dictConfig["tmpdir"] + "/cmd.log 2>&1")
	if iRetCode != 0:
		strOutput=""
		output = file(dictConfig["tmpdir"] + "/cmd.log")
		for line in output.xreadlines():
			strOutput += line
		raise RuntimeError, "Execute error.\nCommand: %s\nReturn Code: %d\nOutput:\n%s" \
					% (cmd, iRetCode, strOutput)

def script_exit(retcode):
	global dictConfig

	if dictConfig["debug"]:
		if retcode != 0:
			traceback.print_tb(sys.exc_traceback)
		print "%s exited with return code %d." % (sys.argv[0], retcode)
	if dictConfig["lock"] != None:
		print "Releasing release lock ...",
		sys.stdout.flush()
		try:
			os.close(dictConfig["lock"])
			os.unlink(dictConfig["prefix"] + "/lock")
			print "done."
		except:
			print "failed:\n%s." % (sys.exc_value)
			print "Could not delete the lock file: %s" % (dictConfig["prefix"] + "/lock")
			print "Please remove it manually!!!\n"
	if dictConfig["keeptmp"]:
		print "\n--keeptmp flag set. Remove the following directories manually:"
		if os.path.exists(dictConfig["tmpdir"]):
			print "\t%s" % (dictConfig["tmpdir"])
		for cleanupdir in dictConfig["cleanupdirs"]:
			if os.path.exists(cleanupdir):
				print "\t%s" % (cleanupdir)
	else:
		print "Cleaning up temporary files ...",
		sys.stdout.flush()
		try:
			sys.stdout.flush()
			if os.path.exists(dictConfig["tmpdir"]):
				shutil.rmtree(dictConfig["tmpdir"])
			for cleanupdir in dictConfig["cleanupdirs"]:
				if os.path.exists(cleanupdir):
					shutil.rmtree(cleanupdir)
			print "done."
		except:
			print "failed:\n%s." % (sys.exc_value)
			print "\nCould not remove the following directories, remove them manually:"
			if os.path.exists(dictConfig["tmpdir"]):
				print "\t%s" % (dictConfig["tmpdir"])
			for cleanupdir in dictConfig["cleanupdirs"]:
				if os.path.exists(cleanupdir):
					print "\t%s" % (cleanupdir)
	print ""
	sys.exit(retcode)

# Parse a Makefile using the Makefile.displayvar trick.
# If Makefile.displayvar this fails which is ok because the tools
# should always be released first (and are not an EPICS package).
def makefile_parse(strFile, strVariable):
	global dictConfig

	# First we must find the path to Makefile.displayvar
	fd = open(dictConfig["prefix"] + "/RELEASE_SITE")
	for strLine in fdin:
		regex = re.match("^[ ]*TOOLS_MODULE_VERSION[ ]*=[ ]*([^# ]*)#*.*$", strLine)
		if regex != None:
			strToolsVersion = regex.group(1)
	fd.close()
	strToolsDir = dictConfig["prefix"] + "/tools/" + strToolsVersion
	strRet = commands.getoutput("make -C %s -f Makefile.displayvar PARSEFILE=%s %s" \
			% (strToolsDir,	strFile, strVariable))
	if strRet.len() == 0:
		raise RuntimeError, "Make variable %s not found in %s" % (strVariable, strFile)
	return strRet

def package_release(strPackage, strVersion):
	global dictConfig

	# Create a directory where files will be checked-out
	strTmpDir = dictConfig["tmpdir"] + "/" + strPackage
	os.makedirs(strTmpDir, 0700)
	# The release branch will be branches/releases/strPackage/strVersion
	strReleaseBranch = dictConfig["svnrepo"] + "/releases/" \
					+ strPackage + "/" + strVersion
	# Detect the path and version to release
	# If it is a patch we won't have to modify the branch we release
	# for a normal release we cannot know yet what will be released
	# (all we know is the revision of the released branch)
	if dictConfig["patch"]:
		strReleaseBranchRev = dictConfig["svnrev"]
		strBranch = strReleaseBranch
		strBranchRev = dictConfig["svnrev"]
	else:
		strReleaseBranchRev = "HEAD"
		strBranch = "%s/%s" % (dictConfig["svnrepo"], dictConfig["branch"])
		strBranchRev = dictConfig["svnrev"]
	# Detect the make variable name for that module
	if strPackage == "base":
		strPackageMakevarName = "EPICS_BASE"
		strPackageVerMakevarName = "BASE_MODULE_VERSION"
	elif strPackage == "extensions":
		strPackageMakevarName = "EPICS_EXTENSIONS"
		strPackageVerMakevarName = "EXTENSIONS_MODULE_VERSION"
	else:
		strPackageMakevarName = os.path.basename(strPackage).upper()
		strPackageVerMakevarName = strPackageMakevarName + "_MODULE_VERSION"
	# ... and the value of what we know now:
	if strPackage == "tools":
		strPackageMakevarNameValue = "%$(EPICS_TOOLS_SITE_TOP)/%s/$(%s)" \
					% (strPackage, strPackageVerMakevarName)
	else:
		strPackageMakevarNameValue = "$(EPICS_SITE_TOP)/%s/$(%s)" \
					% (strPackage, strPackageVerMakevarName)
	# Make sure the branch (or for a patch the release branch) exists
	try:
		execute("svn ls %s" % (strBranch))
	except:
		raise RuntimeError, "cannot access SVN repository %s." % (dictConfig["svnrepo"])
	# Generate the check-in message and calculate the version of the
	# caller selected HEAD
	if strBranchRev == "HEAD":
		print "Detecting revision to release ...",
		sys.stdout.flush()
		try:
			execute("svn info %s" % (strBranch))
			fd = open("%s/cmd.log" % (dictConfig["tmpdir"]))
			for strLine in fd:
				regex = re.match("^Revision:[\s]*([\S]*)$", strLine)
				if regex != None:
					strBranchRev = regex.group(1)
					break
			if strBranchRev == "HEAD":
				raise RuntimeError, "could not determine SVN revision"
			print "done.\nReleasing %s revision %s." % (strBranch, strBranchRev)
		except:
			print "failed.\nERROR: %s." % (sys.exc_value)
			script_exit(90)
	strMessage=""" "RELEASE EPICS Package=%s Version=%s Branch=%s Revision=%s" """ \
				% (strPackage, strVersion, strBranch, strBranchRev)
	# Create a branch named branches/releases/strPackage/strVersion if it is not a patch
	if not dictConfig["patch"]:
		print "Creating new branch for the release ...",
		sys.stdout.flush()
		try:
			# Make sure the branch does not already exist
			bFound = False
			try:
				execute("svn ls %s" % (strReleaseBranch))
				bFound = True
			except:
				pass
			if bFound:
				raise RuntimeError, "already exist!"
			strDir = dictConfig["svnrepo"]
			while strDir != os.path.dirname(strReleaseBranch):
				regex = re.match(strDir + "/([^/]+)/.*", strReleaseBranch)
				if regex == None:
					raise RuntimeError, "unable to process branch %s" \
								% (strReleaseBranch)
				strMatch = regex.group(1)
				strDir += "/%s" % (strMatch)
				try:
					execute("svn ls %s" % (strDir))
					continue
				except:
					pass
				execute("svn mkdir -m %s %s" % (strMessage, strDir))
			execute("svn cp -r %s -m %s %s %s" \
					% (strBranchRev, strMessage, strBranch, strReleaseBranch))
			print "done"
		except:
			print "failed.\nERROR: %s." % (sys.exc_value)
			script_exit(100)
	# Checkout the new branch
	print "Checking out the release ...",
	sys.stdout.flush()
	try:
		execute("svn co -r %s %s %s" % (strReleaseBranchRev, strReleaseBranch, strTmpDir))
		print "done"
	except:
		print "failed.\nERROR: %s." % (sys.exc_value)
		script_exit(105)	
	# Update the local RELEASE_SITE
	if not dictConfig["patch"]:
		print "Update local RELEASE_SITE file ...",
		sys.stdout.flush()
		try:
			bModifyEPICSTop = False
			# Import the RELEASE_SITE from the release area if it exists
			if os.path.exists(dictConfig["prefix"] + "/RELEASE_SITE"):
				shutil.copyfile(dictConfig["prefix"] + "/RELEASE_SITE",
							strTmpDir + "/RELEASE_SITE")
			# Otherwise fix EPICS_SITE_TOP inside the local RELEASE_SITE file
			else:
				bModifyEPICSTop = True
			# Now we must:
			# Fix EPICS_SITE_TOP if needed
			# If a variable with the name of the module is found, remove it: it should
			# not happen except for base and extensions
			shutil.copyfile(strTmpDir + "/RELEASE_SITE",
					strTmpDir + "/RELEASE_SITE.prev")
			fdout = open(strTmpDir + "/RELEASE_SITE", "w")
			fdin = open(strTmpDir + "/RELEASE_SITE.prev", "r")
			for strLine in fdin:
				if bModifyEPICSTop == True:
					regexEPICSTop = re.match("^[\s]*(EPICS_SITE_TOP)[\s]*=",strLine)
					if regexEPICSTop != None:
						fdout.write("EPICS_SITE_TOP=%s\n" % (dictConfig["prefix"]))
						bModifyEPICSTop = False
				regex = re.match("^[\s]*(%s)[\s]*=" % (strPackageMakevarName), strLine)
				if regex == None:
					fdout.write(strLine)
			if bModifyEPICSTop:
				fdout.write("EPICS_SITE_TOP=%s\n" % (dictConfig["prefix"]))
			fdin.close()
			fdout.close()
			# Check-in the changes: we don't need to add the 2 files because they should already exist
			execute("svn ci -m %s %s; svn up" % (strMessage, strTmpDir))
			print "done."
		except:
			print "failed.\nERROR: %s." % (sys.exc_value)
			script_exit(115)
	
	# Now we detect the newly created revision. This one is the one that will go in the release
	# the reason for that is this is the one one should use to re-create what we are building.
	print "Fixing release version ...",
	sys.stdout.flush()
	try:
		if strReleaseBranchRev == "HEAD":
			execute("svn info %s" % (strReleaseBranch))
			fd = open("%s/cmd.log" % (dictConfig["tmpdir"]))
			for strLine in fd:
				regex = re.match("^Revision:[\s]*([\S]*)$", strLine)
				if regex != None:
					strReleaseBranchRev = regex.group(1)
					break
			if strReleaseBranchRev == "HEAD":
				raise RuntimeError, "could not determine release SVN revision"
		strRelVersion = strVersion + "-r" + strReleaseBranchRev
		print "done, it will be %s." % (strRelVersion)
	except:
		print "failed.\nERROR: %s." % (sys.exc_value)
		script_exit(115)
	# Now we can decide what the exact version of the module is
	strInstallLoc = dictConfig["prefix"] + "/" + strPackage + "/" + strRelVersion
	if os.path.exists(strInstallLoc):
		raise RuntimeError, "%s version %s already released" % (strPackage, strRelVersion)
	dictConfig["cleanupdirs"].append(strInstallLoc)

	# Build the module with INSTALL_LOCATION pointing to release area
	# this will release the package in strPackage/strVersion
	print "Building release ...",
	sys.stdout.flush()
	try:
		# This is tricky: we want the branch RELEASE_SITE to be parsed
		os.environ["EPICS_SITE_CONFIG"] = strTmpDir + "/RELEASE_SITE"
		execute("make -C %s all INSTALL_LOCATION=%s" \
				% (strTmpDir + "/" + strPackage, strInstallLoc))
		# If we are releasing the base we must also copy startup (maybe 
		# it should be in base Makefile)
		if strPackage == "base":
			# Remove all SVN files in directories we copy
			execute("find %s -name .svn -exec rm -rf \";\" " % (
					strTmpDir + "/" + strPackage + "/startup ",
				))
			shutil.copytree(strTmpDir + "/" + strPackage + "/startup",
						strInstallLoc + "/startup", True)
		print "done"
	except:
		print "failed.\nERROR: %s." % (sys.exc_value)
		script_exit(110)		
	# Update the release RELEASE_SITE now that we have released the module
	print "Update release RELEASE_SITE file ...",
	sys.stdout.flush()
	try:
		# Only copy branch RELEASE_SITE into release area if there is none existing yet
		# We cannot simply copy the branch RELEASE_SITE because a patch could have an old version
		# of some modules...
		if not os.path.exists(dictConfig["prefix"] + "/RELEASE_SITE"):
			shutil.copyfile(strTmpDir + "/RELEASE_SITE", dictConfig["prefix"] + "/RELEASE_SITE")

		# Now we modify or if necessary add the module path and version to RELEASE_SITE
		shutil.copyfile(dictConfig["prefix"] + "/RELEASE_SITE", strTmpDir + "/RELEASE_SITE.prev")
		fdout = open(dictConfig["prefix"] + "/RELEASE_SITE", "w")
		fdin = open(strTmpDir + "/RELEASE_SITE.prev", "r")
		bFoundVersion = False
		bFoundName = False
		for strLine in fdin:
			regex = re.match("^[\s]*%s[\s]*=" \
						% (strPackageVerMakevarName), strLine)
			if regex != None:
				fdout.write("%s=%s\n" % (strPackageVerMakevarName, strRelVersion))
				bFoundVersion = True
			else:
				regex = re.match("^[\s]*%s[\s]*=" \
							% (strPackageMakevarName), strLine)
				if regex != None:
					fdout.write("%s=%s\n" % (strPackageMakevarName, strPackageMakevarNameValue))
					bFoundName = True
				else:
					fdout.write(strLine)
		if not bFoundVersion:
			fdout.write("%s=%s\n" % (strPackageVerMakevarName, strRelVersion))
		if not bFoundName:
			fdout.write("%s=%s\n" % (strPackageMakevarName, strPackageMakevarNameValue))
		fdin.close()
		fdout.close()
		print "done"
	except:
		print "failed.\nERROR: %s." % (sys.exc_value)
		script_exit(120)		
	# Exception: if package is tools, update the 'current' link
	if strPackage == "tools":
		print "Updating current link ...",
		sys.stdout.flush()
		try:
			if os.path.exists(dictConfig["prefix"] + "/" + strPackage + "/current"):
				os.unlink(dictConfig["prefix"] + "/" + strPackage + "/current")
			execute("ln -s %s %s" % (os.path.basename(strInstallLoc),
					dictConfig["prefix"] + "/" + strPackage + "/current"))
			execute("chgrp lab-admin %s; chmod 775 %s" \
					% (dictConfig["prefix"] + "/" + strPackage + "/current",
					dictConfig["prefix"] + "/" + strPackage + "/current"))
			print "done"
		except:
			print "failed.\nERROR: %s." % (sys.exc_value)
			script_exit(125)
	print "Fixing permissions ...",
	sys.stdout.flush()
	try:
		execute("chgrp -R lab-admin %s" % (strInstallLoc))
		execute("chmod -R ugo-w %s" % (strInstallLoc))
		print "done"
	except:
		print "failed.\nERROR: %s." % (sys.exc_value)
		script_exit(120)
	# If an error occurs do not erase the release directory (it is functional)
	dictConfig["cleanupdirs"].remove(strInstallLoc)
	# Remove temp directory
	if not dictConfig["keeptmp"]:
		shutil.rmtree(strTmpDir)
	print "Package %s version %s released." % (strPackage, strRelVersion)

# Entry point of the script. This is main()

# Set default values
dictConfig = {}
dictConfig["branch"] = "trunk"
dictConfig["svnrev"] = "HEAD"
dictConfig["svnrepo"] = "file:///afs/slac/g/pcds/vol2/svn/pcds/epics"
dictConfig["prefix"] = "/pcds/package/epics"
dictConfig["patch"] = False
dictConfig["debug"] = False
dictConfig["keeptmp"] = False
dictConfig["grpowner"] = "lab-admin"
dictConfig["cleanupdirs"] = []
dictConfig["tmpdir"] = tempfile.mktemp("epics-release")
dictConfig["lock"] = None
try:
	strPackages = ""
	
	# Parse the arguments
	i=1
	while i < len(sys.argv):
		if (sys.argv[i] == "--help") or (sys.argv[i] == "-h"):
			print "%s: release EPICS packages." % (sys.argv[0])
			print "Syntax: %s <package1>=<version> [ <package2>=<version> ... ] \\" % (sys.argv[0])
			print "\t[ --rev <svnrev> ] [ --branch <branch> ] [ --repo <svnrepo> ] \\"
			print "\t[ --release <release_area> ] [ --patch ] \\"
			print "\t[ --debug ] [ --keeptmp ] \\"
			print "\t| --help"
			print "<packageX>: name of the package to release."
			print "<version>: name/version under which the package should be released."
			print "--rev <svnrev>: Which SVN revision to release."
			print "\tNote that the released package will have a different SVN"
			print "\trelease number because this attribute control only the"
			print "\tversion of the source code being used, not the make system."
			print "\t(default is %s)" % (dictConfig["svnrev"])
			print "--branch <branch>: by default use the trunk, but you can release from"
			print "\ta branch using this option."
			print "\t(default is %s)" % (dictConfig["branch"])
			print "--repo <svnrepo>: SVN repository address."
			print "\t(default is %s)" % (dictConfig["svnrepo"])
			print "--release <release_area>: path to the release area to use"
			print "\t(where RELEASE_SITE is located)."
			print "\t(default is %s)" % (dictConfig["prefix"])
			print "--patch: tell the script the release already exists."
			print "--help: display this message."
			print "--debug: display more info when an error occurs."
			print "--keeptmp: does not erase the temp directory being used.\n"
			sys.exit(0)
		elif sys.argv[i] == "--rev":
			i += 1
			dictConfig["svnrev"] = sys.argv[i]
		elif sys.argv[i] == "--branch":
			i += 1
			dictConfig["branch"] = sys.argv[i]
		elif sys.argv[i] == "--repo":
			i += 1
			dictConfig["svnrepo"] = sys.argv[i]
		elif sys.argv[i] == "--release":
			i += 1
			dictConfig["prefix"] = sys.argv[i]
		elif sys.argv[i] == "--debug":
			dictConfig["debug"] = True
		elif sys.argv[i] == "--keeptmp":
			dictConfig["keeptmp"] = True
		elif sys.argv[i] == "--patch":
			dictConfig["patch"] = True
		elif re.match("[^=]*=[^=]*", sys.argv[i]) != None:
			strPackages = strPackages + sys.argv[i]
		else:
			raise RuntimeError, "invalid option or package %s. Try --help" % (sys.argv[i])
		i += 1

	# Check that we have something to do
	if len(strPackages) == 0:
		raise RuntimeError, "No package listed. Try --help"
	print ""

	# Configure the run
	os.makedirs(dictConfig["tmpdir"], 0700)
	lstPackages = [ (pkg.split("=")[0], pkg.split("=")[1]) for pkg in strPackages.split() ]
	os.environ["EPICS_TOOLS_SITE_TOP"] = dictConfig["prefix"]
	
	# Setup a lock to make sure 2 release scripts are not running in //
	print "Acquiring lock for release area %s ..." % (dictConfig["prefix"]),
	sys.stdout.flush()
	try:
		dictConfig["lock"] = os.open(dictConfig["prefix"] + "/lock", os.O_CREAT | os.O_EXCL)
		print "done."
	except:
		if os.path.exists(dictConfig["prefix"] + "/lock"):
			print "failed\nERROR: someone else has the lock, try again later."
		else:
			print "failed\nERROR: could not acquire the lock, check permissions."
			if dictConfig["debug"]:
				print "open: %s." % (sys.exc_value)
		script_exit(5)	
	# Install each package
	for (strPackage, strVersion) in lstPackages:
		strPackageName = re.sub(".*/", "", strPackage)	# strPackage can be a path, strPackageName will always be a name
		print "\nReleasing package %s version %s:" % (strPackageName, strVersion)
		package_release(strPackage, strVersion)
	script_exit(0)
except KeyboardInterrupt:
	print "\nERROR: interrupted by user."
	script_exit(1)
except SystemExit:
	raise
except:
	print "ERROR: %s." % (sys.exc_value)
	script_exit(2)
