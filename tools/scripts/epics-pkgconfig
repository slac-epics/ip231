#!/usr/bin/python
# This script configures an EPICS package so it will work in an environment
# where epics_env.[c]sh has been run.
# It is written for the PCDS group but should be generic enough for most
# environments that us epics_env.
# This script modify configure/RELEASE using the value of several environment
# variables set by epics_env.[c]sh. It can also check and resolve dependencies.
#
# Copyright 2008, Stanford University
# Author: Remi Machet <rmachet@slac.stanford.edu>
#
# Released under the GPLv2 licence <http://www.gnu.org/licenses/gpl-2.0.html>
#

import re
import sys
import shutil
import traceback
import commands
import os
sys.path.append(os.path.dirname(sys.argv[0]) + "/../lib")
import epics

def script_exit(retcode):
	global dictConfig

	if retcode != 0:
		trace = sys.exc_traceback
	if (dictConfig["pkgpath"] != None) and (retcode != 0):
		try:
			print "Restoring modified files ...",
			sys.stdout.flush()
			for backedupfile in dictConfig["backedupfiles"]:
				if os.path.exists(backedupfile + dictConfig["backupsuffix"]):
					shutil.move(backedupfile + dictConfig["backupsuffix"], backedupfile)
			for cleanupfile in dictConfig["cleanupfiles"]:
				if os.path.exists(cleanupfile):
					os.remove(cleanupfile)
			print "done.\n"
		except:
			print "failed:\n%s." % (sys.exc_value)
			print "\nCould not restore the old config, package may be broken."
	if dictConfig["debug"]:
		if retcode != 0:
			traceback.print_tb(trace)
		print "%s exited with return code %d." % (sys.argv[0], retcode)
	print ""
	sys.exit(retcode)


# Entry point of the script. This is main()

# Set default values
dictConfig = {}
dictConfig["INSTALL_LOCATION"] = "$(TOP)"
dictConfig["CROSS_COMPILER_TARGET_ARCHS"] = ""
dictConfig["debug"] = False
dictConfig["checkdeps"] = True
dictConfig["pkgpath"] = None
dictConfig["backupsuffix"] = ".prev";
dictConfig["cleanupfiles"] = []
dictConfig["backedupfiles"] = []
try:
	strPackages = ""
	strList = None
	
	# Parse the arguments
	i=1
	while i < len(sys.argv):
		if (sys.argv[i] == "--help") or (sys.argv[i] == "-h"):
			print "%s: configure the RELEASE file of an EPICS package." % (sys.argv[0])
			print "Syntax: %s [ <package_path> ] [ --help ] \\" % (sys.argv[0])
			print "\t[ --arch <arch1> [ --arch <arch2> ... ] ] \\"
			print "\t[ --install <path> ] [ --nocheck ] [ --debug ]"
			print "<package_path>: package to configure, if none assume current directory."
			print "--arch <archX>: by default the module will be built for all architectures"
			print "\tsupported (some may not be supported by base), you can override this using this option."
			print "--help: display this message."
			print "--install <path>: path where EPICS should install the compiled files."
			print "--debug: display more info when an error occurs."
			print "--nocheck: do not check dependencies."
			script_exit(0)
		elif sys.argv[i] == "--arch":
			i += 1
			dictConfig["CROSS_COMPILER_TARGET_ARCHS"] += " " + sys.argv[i]
		elif sys.argv[i] == "--install":
			i+=1
			dictConfig["INSTALL_LOCATION"] = sys.argv[i]
		elif sys.argv[i] == "--debug":
			dictConfig["debug"] = True
		elif sys.argv[i] == "--nocheck":
			dictConfig["checkdeps"] = False
		elif dictConfig["pkgpath"] == None:
			dictConfig["pkgpath"] = sys.argv[i]
		else:
			raise RuntimeError, "too many arguments. Try --help"
		i += 1

	# Configure all the remaining options
	if dictConfig["pkgpath"] == None:
		dictConfig["pkgpath"] = os.getcwd()
	strReleaseFile = dictConfig["pkgpath"] + "/configure/RELEASE";
	if not os.path.exists(strReleaseFile):
		raise RuntimeError, "no package found in %s" % (dictConfig["pkgpath"])
	if not os.environ.has_key("EPICS_SITE_TOP"):
		raise RuntimeError, "EPICS_SITE_TOP is not defined, you must define it."
	dictConfig["EPICS_SITE_TOP"] = os.environ["EPICS_SITE_TOP"]
	if not os.environ.has_key("EPICS_HOST_ARCH"):
		raise RuntimeError, "EPICS_HOST_ARCH is not defined, you must define it."
	dictConfig["EPICS_HOST_ARCH"] = os.environ["EPICS_HOST_ARCH"]

	# Fix configure/RELEASE
	try:
		print "Fixing package configuration ...",
		sys.stdout.flush()
		dictParams = {}
		dictParams["EPICS_SITE_TOP"] = dictConfig["EPICS_SITE_TOP"]
		dictParams["INSTALL_LOCATION"] = dictConfig["INSTALL_LOCATION"]
		if os.environ.has_key("EPICS_BASE_VER"):
			dictParams["BASE_MODULE_VERSION"] = os.environ["EPICS_BASE_VER"]
		if os.environ.has_key("EPICS_BASE"):
			dictParams["EPICS_BASE"] = os.environ.has_key("EPICS_BASE")
		elif os.environ.has_key("EPICS_BASE_VER"):
			dictParams["EPICS_BASE"] = dictConfig["EPICS_SITE_TOP"] + "/base/" + os.environ["EPICS_BASE_VER"]
		elif os.path.exists(dictConfig["pkgpath"] + "/configure/CONFIG_BASE"):
			dictParams["EPICS_BASE"] = dictConfig["pkgpath"]
		else:
			dictParams["EPICS_BASE"] = dictConfig["EPICS_SITE_TOP"] + "/base/$(BASE_MODULE_VERSION)"
		dictParams["EPICS_MODULES"] = dictConfig["EPICS_SITE_TOP"] + "/modules"
		if os.environ.has_key("EPICS_EXTENSIONS_VER"):
			dictParams["EXTENSIONS_MODULE_VERSION"] = dictConfig["EPICS_EXTENSIONS_VER"]
		if os.environ.has_key("EPICS_EXTENSIONS"):
			dictParams["EPICS_EXTENSIONS"] = os.environ["EPICS_EXTENSIONS"]
		elif os.environ.has_key("EPICS_EXTENSIONS_VER"):
			dictParams["EPICS_EXTENSIONS"] = dictConfig["EPICS_SITE_TOP"] + "/extensions/" + os.environ["EPICS_EXTENSIONS_VER"]
		else:
			dictParams["EPICS_EXTENSIONS"] = dictConfig["EPICS_SITE_TOP"] + "/extensions/$(EXTENSIONS_MODULE_VERSION)"
		if len(dictConfig["CROSS_COMPILER_TARGET_ARCHS"]) != 0:
			expr = re.match("^(.*)\S*" + dictConfig["EPICS_HOST_ARCH"] + "\S*(.*)$", dictConfig["CROSS_COMPILER_TARGET_ARCHS"])
			if (expr != None):
				dictParams["CROSS_COMPILER_HOST_ARCHS"] = dictConfig["EPICS_HOST_ARCH"]
				dictParams["CROSS_COMPILER_TARGET_ARCHS"] = expr.expand(r"\1\2")
			else:
				dictParams["CROSS_COMPILER_TARGET_ARCHS"] = dictConfig["CROSS_COMPILER_TARGET_ARCHS"]
		lstModified = epics.config.edit(dictConfig["pkgpath"], dictParams,
				dictConfig["backupsuffix"])
		dictConfig["backedupfiles"].extend(lstModified)
	except:
		print "failed:\nERROR: %s." % (sys.exc_value)
		script_exit(10)
	print "done."	
	
	if dictConfig["checkdeps"]:
		try:
			print "Parsing configuration ...",
			sys.stdout.flush()
			dictKnownParams = {}
			dictKnownParams["TOP"] = dictConfig["pkgpath"]
			dictKnownParams.update(dictParams)
			# Cleanup invalid values from the dictionary (they are valid in dictParam)
			for param in dictKnownParams.keys():
				if dictKnownParams[param] == None:
					del dictKnownParams[param]
			dictVars=epics.config.parse(strReleaseFile, dictKnownParams)
		except:
			print "failed:\nERROR: %s." % (sys.exc_value)
			script_exit(20)
		print "done."	
		
		# Check dependencies. For that we use the dictionary created by fixconfig and look
		# for 2 env variables X and X_MODULE_VERSION. A special case is EXTENSIONS_MODULE_VERSION
		# which can appear without EXTENSIONS
		print "Checking dependencies ..."
		iErrors = 0
		iWarnings = 0
		if not dictVars.has_key("EXTENSIONS"):
			if dictVars.has_key("EXTENSIONS_MODULE_VERSION"):
				# A very convoluted way to make sure EXTENSIONS_MODULE_VERSION is set properly
				dictVars["EXTENSIONS"] = dictVars["EPICS_EXTENSIONS"] + "/../" + dictVars["EXTENSIONS_MODULE_VERSION"]
			else:
				dictVars["EXTENSIONS"] = dictVars["EPICS_EXTENSIONS"]
		for strKey in dictVars.keys():
			expr = re.match("^(.*)_MODULE_VERSION$", strKey)
			if (expr != None) and dictVars.has_key(expr.expand(r"\1")):
				strModule = expr.expand(r"\1").lower()
				strPath = dictVars[expr.expand(r"\1")]
				strVersion = dictVars[strKey]
				if not os.path.exists(strPath):
					# Look for another version
					if not os.path.exists(os.path.dirname(strPath)):
						print "ERROR: module %s needed by this package not found." % (strModule)
						iErrors += 1
					else:
						print "WARNING: this package requires version %s of %s which" % (strVersion, strModule)
						print "is not installed. Install it or modify %s_MODULE_VERSION." % (strModule.upper())
						iWarnings += 1
		if (iErrors != 0) or (iWarnings != 0):
			print "%d Errors and %d Warnings, please fix before running make." % (iErrors, iWarnings)
		else:
			print "This EPICS package is ready to be used."
	# Done
	script_exit(0)
except KeyboardInterrupt:
	print "\nERROR: interrupted by user."
	script_exit(1)
except SystemExit:
	raise
except:
	print "ERROR: %s." % (sys.exc_value)
	script_exit(2)
