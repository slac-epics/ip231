#!/usr/bin/python
# This script release an EPICS package into the release area.
# It is written for the PCDS group but should be generic enough for most
# environments. To change the release area modify PREFIX or
# use command line option --prefix.
# This script release a package by doing the following:
# 	Look for the package with the requested tag in CVS
#	Check-out a version of the package in a temp directory if sources 
#		should not be installed or ${PREFIX}/src otherwise
#	Decide to do a base, extension or module release:
#		For base do the proper source changes, build and install. 
#			Add necessary scripts
#		For extensions calculate dependencies, build them, making 
#			a distinction between releasing all extensions or 
#			just a new one
#		For modules calculate dependencies and build.
#	Set the permissions properly on the installed files
#	Cleanup
#
# Copyright 2008, Stanford University
# Author: Remi Machet <rmachet@slac.stanford.edu>
#
# Released under the GPLv2 licence <http://www.gnu.org/licenses/gpl-2.0.html>
#

import re
import sys
import shutil
import traceback
import tempfile
import commands
import stat
import os
sys.path.append(os.path.dirname(sys.argv[0]) + "/../lib")
import epics

def execute(cmd):
	global dictConfig

	iRetCode = os.system("/bin/bash -c '(" + cmd + ")' 1>2 2> " + dictConfig["tmpdir"] + "/cmd.log")
	if iRetCode != 0:
		strOutput=""
		output = file(dictConfig["tmpdir"] + "/cmd.log")
		for line in output.xreadlines():
			strOutput += line
		raise RuntimeError, "Execute error.\nCommand: %s\nReturn Code: %d\nOutput:\n%s" % (cmd, iRetCode, strOutput)

def script_exit(retcode):
	global dictConfig

	if dictConfig["debug"]:
		if retcode != 0:
			traceback.print_tb(sys.exc_traceback)
		print "%s exited with return code %d." % (sys.argv[0], retcode)
	if dictConfig["keeptmp"]:
		print "\n--keeptmp flag set. Remove the following directories manually:"
		if os.path.exists(dictConfig["tmpdir"]):
			print "\t%s" % (dictConfig["tmpdir"])
		for cleanupdir in dictConfig["cleanupdirs"]:
			if os.path.exists(cleanupdir):
				print "\t%s" % (cleanupdir)
	else:
		try:
			print "Cleaning up temporary files ...",
			sys.stdout.flush()
			if os.path.exists(dictConfig["tmpdir"]):
				shutil.rmtree(dictConfig["tmpdir"])
			for cleanupdir in dictConfig["cleanupdirs"]:
				if os.path.exists(cleanupdir):
					shutil.rmtree(cleanupdir)
		except:
			print "failed:\n%s." % (sys.exc_value)
			print "\nCould not remove the following directories, remove them manually:"
			if os.path.exists(dictConfig["tmpdir"]):
				print "\t%s" % (dictConfig["tmpdir"])
			for cleanupdir in dictConfig["cleanupdirs"]:
				if os.path.exists(cleanupdir):
					print "\t%s" % (cleanupdir)
		print "done.\n"
	sys.exit(retcode)

# Format of the lstMods: [ [ <regexmatch>, <replace>, <create_if_not_found?> ] ... ]
def modify_file(strFile, lstMods):
	shutil.copy(strFile, strFile + ".prev")
	fdin = file(strFile + ".prev","r")
	fdout = file(strFile,"w")
	for line in fdin.xreadlines():
		for paramcfg in lstMods:
			expr = re.match(paramcfg[0], line)
			if expr != None:
				line = expr.expand(paramcfg[1]) + "\n"
				paramcfg[2] = False
		fdout.write(line)
	for paramcfg in lstMods:
		if paramcfg[2]:
			fdout.write(paramcfg[1] + "\n")
	fdin.close()
	fdout.close()
	os.remove(strFile + ".prev")


# Format of the lstConfigParams: [ [ <param_name>, <param_val>, <create_if_not_found?> ] ... ]
def modifyconfig(strConfigFile, lstConfigParams):
	lst = [ ]
	for paramcfg in lstConfigParams:
		if paramcfg[1] != None:
			lst.append([ "^\s*" + paramcfg[0] + "\s*=.*$", paramcfg[0] + "=" + paramcfg[1], paramcfg[2] ])
	modify_file(strConfigFile, lst)
	

def cleanup_src(arg, dirname, names):
	if names.count(".cvsignore") != 0:
		os.remove(dirname + "/.cvsignore")
		names.remove(".cvsignore")
	if names.count("CVS") != 0:
		shutil.rmtree(dirname + "/CVS")
		names.remove("CVS")


def patch_base(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	
	# Set the environment
	os.environ["EPICS_HOST_ARCH"] = commands.getoutput("%s/startup/EpicsHostArch" % (strSrcDir))
	os.environ["EPICS_SITE_TOP"] = dictConfig["prefix"]
	os.environ["EPICS_BASE_VER"] = strVersion
	# Change make variables in configure/CONFIG_SITE
	modifyconfig(strSrcDir + "/configure/CONFIG_SITE", 
		[ 
			[ "HOST_OPT", "YES", True ],
			[ "COMPAT_TOOLS_313", "NO", True ],
			[ "COMPAT_313", "NO", True ],
			[ "EPICS_SITE_VERSION", "pcds", True ],
			[ "INSTALL_LOCATION", re.sub(dictConfig["prefix"], "$(EPICS_SITE_TOP)", strInstallDir), True ]
		])
	modify_file(strSrcDir + "/configure/CONFIG_SITE",  [
			[ "^\s*CROSS_COMPILER_TARGET_ARCHS\s*=\s*.*$", "CROSS_COMPILER_TARGET_ARCHS?=" + dictConfig["target_arch"], True ],
		])
	# Change RTEMS make variables in configure/os/CONFIG_SITE.Common.RTEMS
	modifyconfig(strSrcDir + "/configure/os/CONFIG_SITE.Common.RTEMS", 
		[ 
			[ "RTEMS_SITE_TOP", dictConfig["rtems_path"], False ],
			[ "RTEMS_VER", dictConfig["rtems_ver"], False ],
		])
	# Fix path in startup files
	for strFile in [ strSrcDir + "/startup/Site.profile", strSrcDir + "/startup/Site.cshrc"]:
		shutil.copy(strFile, strFile + ".prev")
		fdin = file(strFile + ".prev","r")
		fdout = file(strFile,"w")
		for line in fdin.xreadlines():
			line = re.sub("/usr/local/epics/", "${EPICS_SITE_TOP}/", line)
			line = re.sub("/base", "/base/${EPICS_BASE_VER}", line)
			fdout.write(line)
		fdin.close()
		fdout.close()
		os.remove(strFile + ".prev")
	# Create 2 EPICS environment scripts that autodetect the path where EPICS is installed
	fd = file(strSrcDir + "/startup/epics_env.sh","w")
	fd.write("#!/bin/sh\n")
	fd.write("export EPICS_SITE_TOP=" + dictConfig["prefix"] + "\n")
	fd.write("export EPICS_BASE_VER=" + strVersion + "\n")
	fd.write("source " + strInstallDir + "/startup/Site.profile\n")
	fd.write("PATH=\"${PATH}:" + strInstallDir + "/bin/${EPICS_HOST_ARCH}\"")
	fd.close()
	fd = file(strSrcDir + "/startup/epics_env.csh","w")
	fd.write("#!/bin/csh -c\n")
	fd.write("setenv EPICS_SITE_TOP " + dictConfig["prefix"] + "\n")
	fd.write("setenv EPICS_BASE_VER " + strVersion + "\n")
	fd.write("source " + strInstallDir + "/startup/Site.cshrc\n")
	fd.write("set path = ( $path " + strInstallDir + "/bin/$EPICS_HOST_ARCH)")
	fd.close()
	os.chmod(strSrcDir + "/startup/epics_env.sh", stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IWOTH)
	os.chmod(strSrcDir + "/startup/epics_env.csh", stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IWOTH)

def release_base(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	
	# Build and install the base
	execute("make -C " + strSrcDir + " all")
	# Fixup the released code
	shutil.copytree(strSrcDir + "/startup", strInstallDir + "/startup", True)
	# Now we need to do more modification to the build system that will be used by other modules
	modify_file(strInstallDir + "/configure/CONFIG_SITE", [ [ "^\s*INSTALL_LOCATION\s*=.*$", "", False ] ])
	modify_file(strInstallDir + "/configure/CONFIG_COMMON", [ [ "^\s*INSTALL_LOCATION\s*=.*$", "", False ] ])
	modify_file(strInstallDir + "/templates/makeBaseExt/top/configure/CONFIG", 
			[ [ "^\s*INSTALL_LOCATION\s*=\s*\$\(TOP\).*$", "INSTALL_LOCATION?=$(TOP)", False ] ])
	modify_file(strInstallDir + "/templates/makeBaseApp/top/configure/CONFIG", 
			[ [ "^\s*INSTALL_LOCATION\s*=\s*\$\(TOP\).*$", "INSTALL_LOCATION?=$(TOP)", False ] ])
	# Update the current link
	execute("ln -sf " + strVersion + " " + dictConfig["prefix"] + "/base/current")

def patch_extensions(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	
	# Remove EPICS 3.13 build system
	if os.path.isdir(strSrcDir + "/config"):
		shutil.rmtree(strSrcDir + "/config")
	# Set the configuration in configure/RELEASE
	modifyconfig(strSrcDir + "/configure/RELEASE", 
		[ 
			[ "BASE_MODULE_VERSION", dictConfig["base_ver"], True ],
			[ "INSTALL_LOCATION_EXTENSIONS", os.path.abspath(strInstallDir), True ],
			[ "INSTALL_LOCATION", os.path.abspath(strInstallDir), True ],
			[ "EPICS_BASE", os.path.abspath(dictConfig["prefix"]) + "/base/" + dictConfig["base_ver"], True ],
			[ "EPICS_EXTENSIONS", os.path.abspath(strInstallDir), True ],
			[ "CROSS_COMPILER_TARGET_ARCHS", dictConfig["target_arch"], False ],
		])


def release_extensions(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	
	# Build and install the extensions
	execute("source " + dictConfig["prefix"] + "/base/" + dictConfig["base_ver"] + "/startup/epics_env.sh; make -C " + strSrcDir + " all")

def patch_extension(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	

def release_extension(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	

def patch_module(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	

def release_module(strPackageName, strVersion, strSrcDir, strInstallDir):
	global dictConfig
	

def package_release(strPackageName, strVersion, strCVSPath):
	global dictConfig

	strCheckoutDir = dictConfig["tmpdir"] + "/" + strPackageName + "-" + strVersion
	# Try to checkout the package
	try:
		print "Checking out package from CVS ...",
		sys.stdout.flush()
		os.environ["CVSROOT"] = dictConfig["CVSROOT"]
		os.makedirs(strCheckoutDir)
		execute( "cvs checkout -r %s -d %s %s" % (strVersion, strCheckoutDir, strCVSPath))
	except:
		print "failed:\n%s." % (sys.exc_value)
		script_exit(10)
	print "done."
	
	# Detect the package type
	if strPackageName == "base":
		strPackageType = "base"
	elif strPackageName == "extensions":
		strPackageType = "extensions"
	elif os.path.exists(strCheckoutDir + "configure") or os.path.exists(strCheckoutDir + "config"):
		strPackageType = "module"
	else:
		strPackageType = "extension"
	print "Package type is %s." % (strPackageType)

	# Do what's appropriate for the package type (module, base or extension)
	if strPackageType == "base":
		if dictConfig["target_arch"] == None:
			dictConfig["target_arch"] = "RTEMS-beatnik linux-686 linux-athlon"
		strInstallDir = "%s/base/%s" % (dictConfig["prefix"], strVersion)
		strSrcDir = "%s/src/base/%s" % (dictConfig["prefix"], strVersion)
		patch_cmd = patch_base
		release_cmd = release_base
	elif strPackageType == "extensions":
		strInstallDir = "%s/extensions/%s" % (dictConfig["prefix"], strVersion)
		strSrcDir = "%s/src/extensions/%s" % (dictConfig["prefix"], strVersion)
		patch_cmd = patch_extensions
		release_cmd = release_extensions
	elif strPackageType == "extension":
		strInstallDir = "%s/extensions/%s/src/%s" % (dictConfig["prefix"], strVersion, strPackageName)
		strSrcDir = "%s/src/extensions/%s/src/%s" % (dictConfig["prefix"], strVersion, strPackageName)
		patch_cmd = patch_extension
		release_cmd = release_extension
	elif strPackageType == "module":
		strInstallDir = "%s/modules/%s/%s" % (dictConfig["prefix"], strPackageName, strVersion)
		strSrcDir = "%s/src/modules/%s/%s" % (dictConfig["prefix"], strPackageName, strVersion)
		patch_cmd = patch_module
		release_cmd = release_module
	if os.path.exists(strInstallDir) or os.path.exists(strSrcDir):
		raise RuntimeError, "package %s version %s already released" % (strPackageName, strVersion)
	dictConfig["cleanupdirs"].append(strInstallDir)
	dictConfig["cleanupdirs"].append(strSrcDir)
	if strPackageType == "base":
		dictConfig["base_ver"] = strVersion
	else:
		dictConfig["base_ver"] = commands.getoutput("/bin/bash -c 'source " + dictConfig["prefix"] + "/base/current/startup/epics_env.sh; echo ${EPICS_BASE_VER}'")
		print "Using base version %s." % (dictConfig["base_ver"])
	
	# Patch the source code (if necesary)
	try:
		print "Patching the package ...",
		sys.stdout.flush()
		patch_cmd(strPackageName, strVersion, strCheckoutDir, strInstallDir)
	except:
		print "failed:\n%s." % (sys.exc_value)
		script_exit(12)
	print "done."
	
	# Cleanup and Relocate the sources if appropriate
	try:
		print "Releasing source code for the package ...",
		sys.stdout.flush()
		os.path.walk(strCheckoutDir, cleanup_src, None)
		if not os.path.exists(os.path.dirname(strSrcDir)):
			os.makedirs(os.path.dirname(strSrcDir), 0755)
		shutil.copytree(strCheckoutDir, strSrcDir, True)
	except:
		print "failed:\n%s." % (sys.exc_value)
		script_exit(14)
	print "done."
	
	# Release the binaries
	try:
		print "Releasing binaries for the package ...",
		sys.stdout.flush()
		release_cmd(strPackageName, strVersion, strCheckoutDir, strInstallDir)
	except:
		print "failed:\n%s." % (sys.exc_value)
		script_exit(16)
	print "done."
	
	# Change permissions
	try:
		print "Fixing permissions and ownership ...",
		sys.stdout.flush()
		execute("chmod -R o-w %s %s" % (strInstallDir, strSrcDir))
		execute("chmod -R o+r %s %s" % (strInstallDir, strSrcDir))
		execute("chgrp -R %s %s %s" % (dictConfig["grpowner"], strInstallDir, strSrcDir))
	except:
		print "failed:\n%s." % (sys.exc_value)
		script_exit(18)
	print "done."
	
	# Release is done: add package to released packages list
	strReleasedListFile = dictConfig["prefix"] + "/release.lst"
	if not os.path.exists(strReleasedListFile):
		execute("touch %s" % (strReleasedListFile))
		execute("chgrp " + dictConfig["grpowner"] + " " + strReleasedListFile)
		os.chmod(strReleasedListFile, stat.S_IREAD | stat.S_IWUSR | stat.S_IWGRP)
	releasedlist = file(strReleasedListFile, "a")
	releasedlist.write("%s:%s=%s\t# cvs=%s\n" % (strPackageName, strCVSPath, strVersion, dictConfig["CVSROOT"]))
	releasedlist.close()

	# Cleanup
	dictConfig["cleanupdirs"].remove(strInstallDir)
	dictConfig["cleanupdirs"].remove(strSrcDir)


# Entry point of the script. This is main()

# Set default values
dictConfig = {}
dictConfig["CVSROOT"] = "/afs/slac/g/lcls/cvs"
dictConfig["prefix"] = "/pcds/package/epics"
dictConfig["debug"] = False
dictConfig["keeptmp"] = False
dictConfig["processdep"] = None
dictConfig["target_arch"] = None
dictConfig["rtems_path"] = "/pcds/package/rtems"
dictConfig["rtems_ver"] = "rtems-4.7.1-p2"
dictConfig["grpowner"] = "lab-admin"
dictConfig["cleanupdirs"] = []
dictConfig["tmpdir"] = tempfile.mktemp("epics-release")
try:
	strPackages = ""
	strList = None
	
	# Parse the arguments
	i=1
	while i < len(sys.argv):
		if (sys.argv[i] == "--help") or (sys.argv[i] == "-h"):
			print "%s: release EPICS packages." % (sys.argv[0])
			print "Syntax: %s <package1> <package2> ... | --list <pkglist> \\" % (sys.argv[0])
			print "\t[ --arch <arch1> [ --arch <arch2> ... ] ] \\"
			print "\t| --help [ --debug ] [ --keeptmp ] [ --cvs <cvsroot> ] \\"
			print "\t[ --deps | --nodeps ] [ --prefix <instpath> ]"
			print "<package1> <package2> ...: list of packages using the syntax"
			print "\t[<package>:]<cvspath>=<version>. If <package> is not"
			print "\tspecified it is assumed to be the last directory name"
			print "\tin <cvspath>."
			print "--list <pkglist>: file that contains a list of packages to install."
			print "--arch <archX>: by default the module will be built for all architectures"
			print "\tsupported by base, you can override this using this option."
			print "--help: display this message."
			print "--debug: display more info when an error occurs."
			print "--cvs <cvsroot>: change the CVS repository."
			print "\t(default is %s)" % (dictConfig["CVSROOT"])
			print "--deps | --nodeps: force or forbid the release of packages needed to"
			print "\tinstall the requested packages. If neither is specified, the"
			print "\tscript will ask."
			print "--prefix <instpath>: change the release directory."
			print "\t(default is %s)" % (dictConfig["prefix"])
			script_exit(0)
		elif sys.argv[i] == "--arch":
			i += 1
			dictConfig["target_arch"] += " " + sys.argv[i]
		elif sys.argv[i] == "--debug":
			dictConfig["debug"] = True
		elif sys.argv[i] == "--keeptmp":
			dictConfig["keeptmp"] = True
		elif sys.argv[i] == "--cvs":
			i += 1
			dictConfig["CVSROOT"] = sys.argv[i]
		elif sys.argv[i] == "--prefix":
			i += 1
			dictConfig["prefix"] = sys.argv[i]
		elif sys.argv[i] == "--list":
			i += 1
			strList = sys.argv[i]
		elif sys.argv[i] == "--deps":
			if dictConfig["processdep"] != None:
				raise RuntimeError, "you cannot have --deps and --nodeps. Try --help"
			dictConfig["processdep"] = True
		elif sys.argv[i] == "--nodeps":
			if dictConfig["processdep"] != None:
				raise RuntimeError, "you cannot have --deps and --nodeps. Try --help"
			dictConfig["processdep"] = False
		elif re.match("[^=]*=[^=]*", sys.argv[i]) != None:
			strPackages = strPackages + sys.argv[i]
		else:
			raise RuntimeError, "invalid option or package %s. Try --help" % (sys.argv[i])
		i += 1

	# Check that we have something to do
	if (strList == None) and (len(strPackages) == 0):
		raise RuntimeError, "No package listed. Try --help"

	# Configure the run
	os.makedirs(dictConfig["tmpdir"], 0700)
	if strList != None:
		try:
			lstPackages=[]
			pkgfile = open(strList)
			for line in pkgfile.xreadlines():
				line = re.sub("\s*#.*$", "", line)
				lstPackages.append((line.split("=")[0], line.split("=")[1]))
			pkgfile.close()
		except:
			raise RuntimeError, "failed to read %s: %s" % (strList, sys.exc_value)
	else:
		lstPackages = [ (pkg.split("=")[0], pkg.split("=")[1]) for pkg in strPackages.split() ]

	# Install each package
	for (strPackage, strVersion) in lstPackages:
		if len(strPackage.split(":")) > 1:
			strPackageName = strPackage.split(":")[0]
			strCVSPath = strPackage.split(":")[1]
		else:
			strPackageName = re.sub(".*/", "", strPackage)	# strPackage can be a path, strPackageName will always be a name
			strCVSPath = strPackage
		print "Releasing package %s version %s:" % (strPackageName, strVersion)
		package_release(strPackageName, strVersion, strCVSPath)
	script_exit(0)
except KeyboardInterrupt:
	print "\nERROR: interrupted by user."
	script_exit(1)
except SystemExit:
	raise
except:
	print "ERROR: %s." % (sys.exc_value)
	script_exit(2)
