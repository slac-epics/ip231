#
# Site-specific information for all RTEMS targets
#
#-------------------------------------------------------

#
# Specify your desired command-line-input library
#
# RTEMS Genericy System has tecla already built in so
#       use that:
#        - reentrant (readline is not)
#        - more powerful than EPICS commandline
#        - consistent line editor functionality with CEXP
COMMANDLINE_LIBRARY = LIBTECLA
#COMMANDLINE_LIBRARY = EPICS


# Where to find RTEMS and specify version as well:
# 2 cases:
# RTEMS_SITE_TOP is defined: we use it
# otherwise use /pcds/package/rtems
RTEMS_SITE_TOP?=/pcds/package/rtems
ifeq ($(shell if [ ! -d $(RTEMS_SITE_TOP) ]; then echo error; fi),error)
$(error RTEMS_SITE_TOP="$(RTEMS_SITE_TOP)" does not exist)
endif

# 2 cases for the version:
# RTEMS_SITE_TOP is an SVN or CVS directory: version is not defined
# otherwise set RTEMS_VER if not already set
ifeq ($(shell if [ -e $(RTEMS_SITE_TOP)/CVS -o -e $(RTEMS_SITE_TOP)/.svn ]; then echo 1; fi ),1)
	RTEMS_VER=
else
	RTEMS_VER?=rtems-4.7.1
endif

#
# T.S: we use a little bit more flexibility allowing for the
# toolchain and RTEMS proper to reside in independent locations.
# Traditionally, only RTEMS_BASE is defined here and the EPICS
# Makefiles assume the following setup:
#
# Toolchain:
#
#    $(RTEMS_BASE)/bin
#
# RTEMS:
#
#    $(RTEMS_BASE)/
#
# I find it better if we have two variables, one for the toolchain
# and another one for RTEMS:
#
# TOOLCHAIN (we use the old name 'RTEMS_BASE' because it is already used
# by other Makefiles. However, if this is ever merged back a name change
# to e.g., RTEMS_TOOLS_BASE would be more appropriate):
#
#   $(RTEMS_BASE)/bin
#
# RTEMS main 'Makefile.inc' (which pulls in more pieces...)
#
#   $(RTEMS_MAKEFILE_PATH)
#
# Having two variables allows us to keep the tools and rtems in different
# places (or not). I usually add a layer of directories so we can support
# multiple cross-host architectures:

# RTEMS Tools
RTEMS_BASE	= $(RTEMS_SITE_TOP)/$(RTEMS_VER)/host/i386_linux2x/

# RTEMS Makefile Path
RTEMS_MAKEFILE_PATH	= $(RTEMS_SITE_TOP)/$(RTEMS_VER)/target/$(RTEMS_TARGET_CPU)-rtems/$(RTEMS_BSP)/

# RTEMS Site Extensions (Cexp, libtecla, libbspExt + many more)
RTEMS_SITE_INSTALLDIR	= $(RTEMS_SITE_TOP)/$(RTEMS_VER)/target/ssrlApps/$(RTEMS_TARGET_CPU)-rtems/$(RTEMS_BSP)/


# If you're using neither BOOTP/DHCP nor FLASH to pick up your IOC
# network configuration you must specify your Internet Domain Name here
#
# T.S: No need for network configuration from EPICS. This is all taken
# care of by the Generic System and the (net)boot process.
#
#OP_SYS_CFLAGS += -DRTEMS_NETWORK_CONFIG_DNS_DOMAINNAME=aps.anl.gov

# Pick up local extensions 
ifdef RTEMS_SITE_INSTALLDIR
ifndef RTEMS_SITE_INCDIRS
RTEMS_SITE_INCDIRS = $(RTEMS_SITE_INSTALLDIR)/include
endif
ifndef RTEMS_SITE_LIBDIRS
RTEMS_SITE_LIBDIRS = $(RTEMS_SITE_INSTALLDIR)/lib
endif
endif

# Search for additional includes
ifdef RTEMS_SITE_INCDIRS
CROSS_INCLUDES += $(addprefix -I,$(RTEMS_SITE_INCDIRS))
endif

# Search for additional libraries
ifdef RTEMS_SITE_LIBDIRS
CROSS_LDFLAGS  += $(addprefix -L,$(RTEMS_SITE_LIBDIRS))
endif

# We want debugger symbols even with optimization
OPT_CFLAGS_YES   = -g -O3
OPT_CXXFLAGS_YES = -g -O3

# GCC_EXEC_PREFIX setting is wrong (maybe due to very old vxworks gccs ?)
# and unnecessary. It will mess up things if the toolchain is relocated
# from it's 'configure'd location. W/o GCC_EXEC_PREFIX recent gccs work
# just fine...
unexport GCC_EXEC_PREFIX

# Partial link only
#
# Change suffix
override EXE   = .obj

# Replace EPICS' RTEMS specific LDFLAGS 
# (Ideally, we'd have two different sets:
# LDFLAGS_CEXP_NO, LD_FLAGS_CEXP_YES...
#
OP_SYS_LDFLAGS = $(CPU_CFLAGS) -Wl,-r
# to strip debugging symbols add:
# OP_SYS_LDFLAGS += -Wl,-S

# Note that some BSP-specific CONFIG.Common.RTEMS-<bsp> files
# still add things that are not appropriate for run-time linking
# :-(. So far they don't seem to harm us but it's not a good situation...
#
# We could add bsp-specific CONFIG_SITE.Common.RTEMS-<bsp> files
# to remedy this...

# Don't bother to build munched binaries
MUNCH_CMD=
MUNCHNAME=

# Redefine final linking command so that only a partial link is done.
# We must make sure nothing that is already present in the system
# is linked again here (RTEMS, libc, libtecla, NFS, you name it...)
# OTOH, linking EPICS libraries (base, site/aka modules, IOC application
# is OK).
OP_SYS_LDLIBS  =

LINK.cpp  = $(CCC) -nostdlib -o $@ $(STATIC_LDFLAGS) $(PRODDIR_LDFLAGS) $(LDFLAGS)
LINK.cpp += $(PROD_LDFLAGS) $(PROD_LD_OBJS) $(PROD_LD_RESS) $(PROD_LDLIBS)
