-*- outline -*-

This file contains information about the version numbers
and what's changed.
Hopefully, the #defines ETHERIP_MAYOR and ETHERIP_MINOR
in ether_ipApp/src/drvEtherIP.h are updated accordingly,
so that you can see the current version at runtime via
drvEtherIP_report.

* 2006, 06/06 V2.15
The code for determining the multi-request-count
had a bug: When a scan list had too many entries,
it wouldn't work at all (tags remain with "- no data -").

Some more info on the buffer limit, EIP_buffer_limit:
The default is 500, which seems to work in most cases,
but the exact size is unknown.
You can only change EIP_buffer_limit in the startup file
_before_any_other_EIP_routine is called!
It applies to both the request and the response data packages.
The driver will only assemble requests which are sized below
the buffer limit, and whose expected reply (data) is also below
the buffer limit.
These are possible errors and what to do about them.
You might have to set EIP_verbosity high enough to see the errors.

1) Request failed, ... "Buffer too small, partial data only"
This is an error message from the PLC. The PLC tried to return data
for a request, but couldn't, because the PLC's buffer is too small.
--> decrease EIP_buffer_limit, because the response needs to be
    made smaller.

2) Request failed, ... "Service not supported" or other error.
Also an error from the PLC. Might mean that the request was too big,
so the PLC didn't understand the request at all, returning some
error.
--> decrease EIP_buffer_limit, so that the driver will send smaller requests.

3) "Tag 'xyz' exceeds buffer limit of ... bytes"
An error from the driver. The single tag 'xyz' has either a request size
(basically: tag name length) or a response size (basically: data size)
that exceeds the buffer limit.
The driver won't even try to send that request to the PLC.
--> increase EIP_buffer_limit, so that the driver will try.
    If you then run into errors 1 or 2, you're out of luck.
    The tag's name (unlikely) or the tag's data (probably) are too big,
    so you have to use fewer array elements in the tag,
    rearrange the data on the PLC to reside in several tags.

4) "EIP_reserve_buffer refuses to allocate ... bytes"
An error from the driver. We know that the actual PLC buffer limit
is around 500, so the driver has a hard limit of 600 which you
cannot exceed. If you set EIP_buffer_limit to >600,
the driver will give this error message.
Could also be caused by a faulty PLC response:
A packet returned from the PLC that claims to contain >600 bytes
of data. Instead of running out of memory, the driver will reject
such responses and disconnect/reconnect.

* 2006, 04/06 V2.14
Minor tweak to allow longer product name in Identity,
since Compact Logix then seems to work ok.

* 2006, 03/10
The error message about hitting the buffer limit is now
more verbose (at EIP_verbosity 3  or higher) to help
with finding the culprit:

Assume this output from drvEtherIP_report:
...
*** Tag 'P1R0' @ 0x8054278:
  scanlist            : 0x8054220
  compiled tag        : 'P1R0'
  elements            : 4
  cip_r_request_size  : 10
  cip_r_response_size : 22
  cip_w_request_size  : 28
  cip_w_response_size : 4
  data_lock ID        : 0x8054320
  data_size (buffer)  : 0
  valid_data_size     : 0
  do_write            : no
  is_writing          : no
  data                : -no data-
  transfer time       : 0 secs
...
and 
   EIP_buffer_limit=20
in the startup file, you'll get the following error message:

Tag 'P1R0' exceeds buffer limit of 20 bytes,
 Request   size:         10 bytes
 Response  size:         22 bytes
 Total  request:         20 bytes
 Total response:         30 bytes

Meaning:
The request, something like "CIP read 'P1R0'",
takes 10 bytes. That's OK.
Wrapped with what's necessary so send it,
it turns into 20 bytes. Still OK.
But the raw data that we expect back would be 22 bytes,
resulting in a total response packet size of 30 bytes.
Not OK when we assume that 20 bytes is the limit.

* 2006, 02/07  V2.13
The PLC or the ENET module or both have a buffer limit.
Comments in ether_ipApp/src/ether_ip.h give some details
on the difficulty in finding the exact limit.
When the the driver tries to read too much data at a time,
it run into "status 0x06 (Buffer too small, partial data only)"
errors from the PLC.
Then the limit is set too small, one cannot read arrays
that hit the limit.
I thought I had determined the exact limit via read and write
tests on a PLC back in October 2002.
Now, the update of the SNS CF IOCs shows that this value
is wrong, at least for the CF PLCs or ENET modules.

Changes:
1) A message that indicates when the driver hits the limit
and refuses to read or write.
Before, you simply had INVALID records with no idea why.

2) A new EIP_buffer_limit configuration value,
defaulting to 500 because that worked for the CF IOCs.
The previous default was 538-52 = 486.

* 2005, 12/13  V2.12
Fix for the case where the IOC might not fully reconnect
after a PLC was reprogrammed.
With EIP_verbosity=10, one could see that the driver
would reconnect:

  EIP connectWithTimeout(my_plc:0xAF12, 5 sec, 0 msec)
  EIP connected to rfq-mod-plc:0xAF12 on socket 52
  EIP sending ListServices encapsulation command
  ....
and successfully gather some information,
  ------------------------------
  Identity information of target:
      UINT vendor         = 0x0100
  ....
      USINT name          = '1756-ENET/B '
  ------------------------------
but then immediately disconnect:
  EIP sending UnRegisterSession encapsulation command, session ID 0x0202F900
  ....
  EIP disconnecting socket 52
  drvEtherIP: PLC 'mod' is disconnected

The fault was in the routine which initially reads
every tag via a new connection in order to obtain
the data sizes.

In addition, drvEtherIP_report no longer locks
anything. So it might print nonsense values in very
rare cases, but to me that beats hanging when
one tries to debug a driver thread.

Eliminated a vxWorks compiler warning about inet_addr(),
where the VXW lack the 'const' that Linux uses.

* 2005, 09/26  V2.11
In case of communication errors during an initial 'read'
of all tags, the network socket might have been left open.

* 2005, 04/19  V2.10
EIP_verbosity>=10 will now print a message for the initial 'connect'
call, which might help debug a situation where the driver
cannot connect: You should now see a difference between a connection
timeout (network problem, device not there) and a refused connection
(possibly the wrong IP address).

Change to AI record support:
Before, no conversion via LINR was supported.
In fact the device support code forced LINR=NO CONVERSION.
From now on, LINR==SLOPE is allowed,
in which case you configure the record's ESLO and EOFF
fields, and the record will then perform a linear conversion
from the RVAL field to the VAL field:
              VAL = (RVAL * ESLO) + EOFF

Similarly, the AO record will convert VAL to RVAL:
            RVAL = (VAL - EOFF) / ESLO

Note, however, that this only makes sense for records that
are communicating with tags of type other than REAL.
Only tags of type INT, DINT, ... will be read into the RVAL
field (AI records) or be written from the RVAL field (AO recs).
Tags of type REAL are directly read into respectively written
from the VAL field, and all those VAL <-> RVAL conversions
are performed in vain.

* 2005, 01/28  V2.9
Driver's delay in disconnecting/reconnecting could be almost
zero in some cases. Now fixed to ~5 secs.
Buffer code rejects requests for buffers >> PLC buffer limit,
trying to avoid memory trouble.
Turned optimization off.

* 2004, 10/06  V2.8
The "-w" flag of ether_ip_test didn't pack the REAL value,
so it didn't work on all CPU types.

Tag parsing changes. Take this setup:
  Nested NESTED;
  DATATYPE Nested
     BOOL BOOLs[32];
     REAL REALs[2];
     TestStruct STRUCTS[5]
  DATATYPE TestStruct
     INT INT;
     REAL REAL;
     DINT DINT;
     BIT BOOL;
(RSLogix actually adds some pads that are omitted in here)

This one worked: 'NESTED.REALs[1]'
Access to this one failed: 'NESTED.STRUCTs[1].REAL',
since in general sub-elements of arrays weren't handled.
This has been fixed.

* 2004, 8/27  V2.7
Changes from Stephanie Allison:
Replaced the registration via a static class instance's
constructor with a DBD file registrar() entry.
Removed some compiler warnings from usage of "size_t"
in printf formats.

* 2004, 8/3  V2.6
The SNS was using a patched versions of 2.5 that included
error messages for the case that the clock jumps:
The scheduling is based on the current time as
reported by epicsTimeGetCurrent(). A 1 second scan list
schedules itself for the time of the last run + 1 second.
A jump in time to e.g. 1 month in the future would trick the driver,
thinking that the last run was one month in the future and
the next run is that one month ahead (plus 1 second).

Now, the code attempts some reset in case of running into
that error.

* 2004, 3/17 V2.5
The timing was wrong under R3.13, keeping the driver thread
from sleeping. The code always uses the R3.14-type epicsTimeStamp,
epicsTimeGetCurrent, epicsThreadSleep etc.  When running under
R3.13, compatibility code implements the missing R3.14 routines.
Those compatibility routines contained a pretty dumb error after the
deadlock-fix from V2.4.

Symptoms include:
- driver thread used a lot of CPU in the "spy" report.
- The "scan thread slow" count in the drvEtherIP_report
  would increment by hundreds per second.
- All that kept the driver thread from using 100% of the
  CPU and flooding the network was the slow response of the
  PLC, which kept the network load within 1% in a test
  in my office.
 
The CPU usage of the driver thread in the "spy" report
is now back to 0% for test.db, sometimes going up to 3%.
The "scan task slow" messages are almost completely gone
under vxWorks w/ R3.13.9, where the "epicsTimeStamp" compatibility
routines use VX ticks.
Under R3.14, the epicsTime.. and epicsThreadSleep.. routines
end up converting between VX ticks, the wallclock, and back.
As a result, the scheduling isn't that perfect. Even after
considering the epicsThreadSleepQuantum, the "scan thread slow"
count can increment every few minutes.
All that means is that a scan list has been due for 1 or two
VX ticks (typically 0 ... 0.03 secs) and the driver overslept.
Compared to the network delays of talking to the PLC, that's
neglectable and not worth reverting to vxWorks-only code.

* 2004, 3/2 V2.4
Review of the R3.14 changes.

Using R3.14 epicsThreadPriorityHigh for the driver thread.
Before, the driver ran below the database, meaning that
the database could be forced to wait for the driver.

Replaced epicsEvent... calls with epicsMutex...:
EpicsMutex is based (for vxWorks) on the semM-type,
providing inversion safety etc.
Unfortunately, epicsMutex doesn't implement any
lock-with-timeout, so whenever we used to run into
a timeout, we're now hung.
One such instance was between the driver thread
and the database: Callbacks from the driver into
device support triggered processing of records.
A deadlock resulted when a record, being processed,
wanted to access the driver tag data, while at the
same time the driver had that tag locked and wanted
to process the record, hanging in dbLock.
The symptom:
   "tag <tagname>: no lock"
messages, then after a timeout things went on
and the record was temporarily INVALID.
For some reason this only happened under vxWorks,
I'be never seen it under Linux with same EPICS database.

Looks like that's resolved.

In case another hangup occurs, try:
     epicsMutexShowAll 1, 10
which lists all locked mutexes and the threads
waiting for them.

* 2004, 02/11 V2.3 
(CVS Release Tag --> ether_ip-2-3)
Create munch file to support
IOC run-time loading (RTL) of
the ether_ip driver libraries

* 2003, 10/31 V2.2
R3.14.4 port

* V2.1
waveform supports CHAR

* 2003, 04/29 V2.0
Stephanie Allison, saa@SLAC.Stanford.EDU, 
ported the EtherIP support to EPICS R3.14!
This added some #ifdefs, the R3.13 support
is hopefully as before.

With R3.14 it now seems to run on
- mv167/vxWorks/R3.13.6
- ppc604/vxWorks/R3.14.1
- ppc604/RTEMS/R3.14.1
- sparc/solaris/R3.14.1
- Linux (RedHat 8.0)

Thanks a lot to Stephanie!

* V1.11
forgot what changed

* 2002, 10/16 V1.10
Tested read access for various numbers of scalar and array tags.
Found that all is OK until either the request or response buffer
reaches 538 bytes. Unclear how "538" relates to the numbers "504"
or "511" found in the EtherIP spec.

Hopefully fixed the driver:
Before, only the read/write and data portion were limited to 500 bytes,
now the total is limited to 538 bytes.

* 2002, 10/15
Pilar created a perfectly fine database that causes
communication errors, causing the PLC to return an error code
that indicates "does not fit in buffer".

There is a limit for the PLC transfer buffer, about 500 bytes.
Spec page P. 2-5 mentions "504 bytes" as the CIP UCMM limit,
Spec page 156 in version 2.0, errata 2 mentions "511 bytes"
as the "Forward_Open" connection size limit.

None if this tells me exactly where the limit is
and whether it's 500 or 504 or ??
Is it in the PLC controller, so the Ethernet overhead
(encapsulation header) is handled by the ENET module
and does not count?
Is it in the ENET module, so the total inc. encapsulation
is limited?

Introduced a new EIP_PROTOCOL_OVERHEAD macro
based on the encapsulation header size
which for now reduces the used buffer size to 446 bytes.

* 2002, 10/02 V1.9
Support for stringin record and STRING type tags

* 2002, 09/24 V1.8
Better handling of disconnects and re-connects for output
records.

Input records are usually scanned. They change when
the value of the PLC tag changes, they turn READ/INVALID
when the tag isn't found on the PLC or when the connection
to the PLC goes down.

For output records, this was meant to be similar:
Most of the time, the driver _reads_ the tags used in output records.
Only when the output record is processed, the driver _writes_ the tag
(in fact the whole array when the tag is part of an array).
Whenever the driver notices a difference between the tag's value
read from the PLC and the output record, it updates the record and
processes it.
What the driver didn't do: Update output records when the PLC
disconnects. Before, one would have to process the output record
(example: Enter new value on screen) and only then would the output
record change to INVALID/WRITE.

Now output records get reprocessed not only for value discrepancies
but also for missing values (disconnect).

* 2002, 08/15 V1.7
When you omit the call to 
     drvEtherIP_define_PLC  <plc>, <IP>, <slot>
the driver (actually device support) reports
"unknown PLC xxx".
This is an indication of a severe error in
either the EPICS database or vxWorks startup script:
All PLCs that you intend to use must be defined,
the driver cannot guess to what PLC you intend to talk.

Before V1.7, the driver used to run into follow-up errors
that suspended scan tasks which included analog input records
which tried to access that unknown PLC.

From V1.7 on, those AI records will just show
INVALID/READ severity and status but no longer
suspend the scan task.

Note: Omitting the call drvEtherIP_define_PLC
is still highly discouraged.
The fix is just a little nicer than the previous
behavior.

* 2002, 06/26 V1.6
This part is not new but just a description
of current behavior of AI, AO records:
When attached to REAL (float) tags,
they read & write the (floating point) VAL fields.
For INT, DINT, ... tags they use the RVAL fields.

RVAL is a signed long,
all INT, DINT tags of the PLC are signed,
but for some reason I happened to transfer them
as "unsigned".
New: I now use signed values.

* 2002, 05/09
Log message for "EIP: Cannot read tag"
didn't show the tag but garbage.

* 2002, 04/30 V1.5
SCAN="I/O Intr" was broken.

* 2002, 03/15 V1.4
Hopefully fixed a problem that occurs when device requests write while
driver is in the middle of a read (used to look as if the PLC didn't
get the write)

* 2002, 02-19 V1.3

** Added "FORCE" option to output records
Per default, output records scan when they are
not writing a new value.
If they notice that the PLC has a different value
for the tag, teh record will adapt the tag's value.

With the new force option, the output record will
try to re-write until the PLC tag matches the
value of the record.

* 2001, 10-01 V1.2

** New driver option "drvEtherIP_default_rate"

* 2001, 08-30 (not versioned)

** Patch to output records
Output records are for writing to the PLC.
But most of the time they are readong from the PLC
and if there is a difference between the record's value
and the PLC tag, the record is updated and processed.

New: This will now happen if the record is UDF.
Before, a record would start as UDF, value 0,
and unless the tag happened to be !=0, the record
stayed UDF. Now the record will be updated/initialized
after e.g. a reboot with the tag value.

* 2001, 06-19    V1.1

** New "B <bit>" flag:
Allows connection of binary records to non-BOOL arrays like INT, DINT.
With B <bit> flag, the array element is used as is
(no longer interpreted as a bit element) and the bit within the INT
or DINT is selected via the new flag:

   INP="@plc1 DINTs[40]"
still results in reading bit 40, that is bit 8 in the second
DINT.

Now this can be written as
   INP="@plc1 DINTs[1] B 8"

A lot of ether_ipApp/doc/readme.txt, the "manual", has been rewritten.


* 2001, 05-18    V1.0

** New "slot" parameter: drvEtherIP_define_PLC <name>, <ip_addr>, <slot>

Before, the driver assumed that the PLC would be in slot 0,
the left-most slot of the ControlLogix crate.

Now you can put it anywhere (in the crate),
but if it's not slot 0, you have to specify that
when you define the PLC.

** Some changes to output of drvEtherIP_report
Now displaying the PLC interface info, e.g.:
  Interface name        : 1756-ENET/A 
  Interface vendor      : 0x100
  Interface type        : 0xC00
  Interface revision    : 0x112
  Interface serial      : 0x13D40700


